/*
 * Copyright © 2018-2019 Alain Kägi
 */

package ldbc.queries;

import com.ldbc.driver.workloads.ldbc.snb.interactive.LdbcQuery14Result;

import com.zaxxer.hikari.HikariDataSource;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Set;
import java.util.Stack;

import ldbc.utils.LdbcUtils;

/**
 * The Query14 class implements an application that runs complex read
 * query 14 from the LDBC Social Network Benchmark (SNB) as a
 * microbenchmark.  As input, it expects a parameter substitution
 * parameter file as generated by the LDBC SNB data generator.
 */
public class Query14 implements ExecutableQuery {

    /* Static query parameters. */
    private static final String queryName = "Query14";
    private static final String queryParameterFilename = "interactive_14_param.txt";
    private static final String queryParameterFileLinePattern = "(\\d+)\\|(\\d+)";

    /** A minimal constructor. */
    private Query14() {}

    /**
     * Run LDBC SNB complex read query 14 as a microbenchmark.
     *
     * <p>A configuration file called <tt>params.ini</tt> specifies
     * the running parameters.
     *
     * @param args  Unused
     */
    public static void main(String[] args) {
        Microbenchmark.executeQueryWithParametersFromFile(new Query14(), queryName, queryParameterFilename, queryParameterFileLinePattern);
    }

    /**
     * Weighted/unweighted paths (14th complex read query).
     * @param ds         A data source
     * @param person1Id  The start person's unique identifier
     * @param person2Id  The end person's unique identifier
     * @return all shortest paths between the given persons; compute a weight for each path
     * @throws SQLException if a database access error occurs
     */
    public static List<LdbcQuery14Result> query(HikariDataSource ds, long person1Id, long person2Id) throws SQLException {
        List<LdbcQuery14Result> results = new ArrayList<>();

        try (Connection c = ds.getConnection()) {
            // Find the length of the shortest path between the given persons.
            int len = findShortestPathLength(c, person1Id, person2Id);
            if (len > 0) {
                List<Stack<Long>> paths;
                // Find all paths between the given persons.
                paths = findAllShortestPaths(c, person1Id, person2Id, len);

                // Compute the weights and add to the results
                // (unsorted for now).  To do so, iterate over the
                // paths.
                for (Stack<Long> path : paths) {
                    double weight = 0.0;
                    long prevFriendId = -1;

                    for (long friendId : path) {
                        // If we have a pair of friends...
                        if (prevFriendId != -1) {

                            // First look at the relationship previous
                            // friend -> friend.
                            for (long messageId : LdbcUtils.getMessagesCreatedBy(c, prevFriendId)) {
                                // Skip posts.
                                if (LdbcUtils.isMessageAPost(c, messageId))
                                    continue;

                                long parentMessageId = LdbcUtils.getParentMessageId(c, messageId);
                                long authorId = LdbcUtils.getAuthorOf(c, parentMessageId);
                                if (authorId == friendId) {
                                    if (LdbcUtils.isMessageAPost(c, parentMessageId))
                                        weight += 1.0;
                                    else
                                        weight += 0.5;
                                }
                            }

                            // Second look at the relationship friend
                            // -> previous friend.
                            for (long messageId : LdbcUtils.getMessagesCreatedBy(c, friendId)) {
                                // Skip posts.
                                if (LdbcUtils.isMessageAPost(c, messageId))
                                    continue;

                                long parentMessageId = LdbcUtils.getParentMessageId(c, messageId);
                                long authorId = LdbcUtils.getAuthorOf(c, parentMessageId);
                                if (authorId == prevFriendId) {
                                    if (LdbcUtils.isMessageAPost(c, parentMessageId))
                                        weight += 1.0;
                                    else
                                        weight += 0.5;
                                }
                            }

                        }

                        prevFriendId = friendId;
                    }

                    LdbcQuery14Result result = new LdbcQuery14Result(path, weight);
                    results.add(result);
                }
            }

            c.commit();
        }

        // Sort out results.
        Collections.sort
            (results,
             new Comparator<Object>() {
                 @Override
                 public int compare(Object o1, Object o2) {
                     LdbcQuery14Result r1 = (LdbcQuery14Result)o1;
                     LdbcQuery14Result r2 = (LdbcQuery14Result)o2;
                     double w1 = r1.pathWeight();
                     double w2 = r2.pathWeight();
                     return Double.compare(w2, w1); // Descending
                 }
             });

        return results;
    }

    /**
     * Find the length of the shortest path between two persons using the Knows relationship.
     *
     * We walk the graph induced by the Knows relationship in a
     * breast-first search fashion.  We stop when we find the end node
     * (person2Id).  We explore all the friends of the persons
     * contained in the variable 'open'.  We had each visited friend
     * in the variable 'close'.  The variable 'open' begins with the
     * starting node (person1Id).  We had to 'open' in waves through
     * the variable 'nextOpen' to compute the path's length.
     *
     * @param db         A database handle
     * @param person1Id  Start person
     * @param person2Id  End person
     * @return the length of the shortest path between the two given persons (-1 if there is no paths, 0 if start and end persons are the same)
     * @throws SQLException if a database access error occurs
     */
    private static int findShortestPathLength(Connection db, long person1Id, long person2Id) throws SQLException {
        if (person1Id == person2Id)
            return 0;

        int pathLength = -1;

        // Breadth-first search:
        // open: the nodes at the current distance
        // nextOpen: the nodes at the current distance + 1
        // close: the nodes we have already seen
        Queue<Long> open = new LinkedList<>();
        Queue<Long> nextOpen = new LinkedList<>();
        Set<Long> close = new HashSet<>();

        int distance = 1;
        open.add(person1Id);
        close.add(person1Id);

        String friendQuery =
            "   SELECT PersonKnowsPerson.person2Id " +
            "     FROM PersonKnowsPerson " +
            "    WHERE PersonKnowsPerson.person1Id = ?";

        ResultSet r = null;

        try (PreparedStatement s = db.prepareStatement(friendQuery)) {
            bfs:
            while (!open.isEmpty()) {
                for (long personId : open) {
                    s.setLong(1, personId);
                    r = s.executeQuery();
                    while (r.next()) {
                        long friendId = r.getLong("PersonKnowsPerson.person2Id");

                        if (close.contains(friendId))
                            continue;

                        nextOpen.add(friendId);
                        close.add(friendId);

                        if (friendId == person2Id) {
                            pathLength = distance;
                            break bfs;
                        }
                    }
                }

                ++distance;
                open = nextOpen;
                nextOpen = new LinkedList<>();
            }
        }
        finally {
            if (r != null) r.close();
        }

        return pathLength;
    }

    /**
     * Find all shortest paths between two persons.
     *
     * We walk the graph induced by the Knows relationship in a
     * depth-first search fashion.
     *
     * @param db         A database handle
     * @param person1Id  The start person's unique identifier
     * @param person2Id  The end person's unique identifier
     * @param length     Length of the shortest path (must be greater than 1)
     * @return all paths between the two given persons as a List of List of person identifiers
     * @throws SQLException if a database access error occurs
     */
    private static List<Stack<Long>> findAllShortestPaths(Connection db, long person1Id, long person2Id, int length) throws SQLException {
        // A candidate shortest path.
        Stack<Long> path = new Stack<>();
        // List of shortest paths found so far.
        List<Stack<Long>> paths = new ArrayList<>();

        path.push(person1Id);
        doFindAllShortestPaths(db, paths, path, person1Id, person2Id, length);

        return paths;
    }

    /**
     * Where the actual work of finding all shortest paths takes place.
     *
     * We pass the list of shortest paths and the current candidate
     * shortest path as parameters so we can call this function
     * recursively.
     *
     * We might consider using Deque instead of Stack, see comment
     * associated with Java 7 Stack.
     *
     * @param db         A database handle
     * @param paths      A list where we accumulate all found paths
     * @param path       A candidate shortest path
     * @param person1Id  The start person's unique identifier
     * @param person2Id  The end person's unique identifier
     * @param length
     * @throws SQLException if a database access error occurs
     */
    private static void doFindAllShortestPaths(Connection db, List<Stack<Long>> paths,Stack<Long> path, long person1Id, long person2Id, int length) throws SQLException {
        if (length == 0)
            return;

        for (long friend : LdbcUtils.findFriends(db, person1Id)) {
            if (friend == person2Id) {
                assert length == 1;
                path.push(friend);
                // Originally I had
                // "paths.add((Stack<Long>)path.clone())" but it
                // causes the compiler to generate a warning
                // (unchecked cast).  The warning could have been
                // suppressed, but I prefer not to annotate the code
                // unless there is no other solution.
                Stack<Long> dup = new Stack<>();
                dup.addAll(path);
                paths.add(dup);
                path.pop();
                return; // at most one connection between person1Id and person2Id when length is equal to 1
            }
            else if (!path.contains(friend)) {
                path.push(friend);
                doFindAllShortestPaths(db, paths, path, friend, person2Id, length - 1);
                path.pop();
            }
        }
    }

    /**
     * Execute the query once for every query parameters.
     * @param db               A database handle
     * @param queryParameters  Stream of query input parameters
     * @param beVerbose        Print query outputs if true
     * @param printHeapUsage   Print heap usage if true
     * @throws SQLException if a database access error occurs
     */
    public void executeQuery(HikariDataSource db, QueryParameterFile queryParameters, boolean beVerbose, boolean printHeapUsage) throws SQLException {
        HeapUsage heapUsage = new HeapUsage();

        while (queryParameters.nextLine()) {
            long person1Id = queryParameters.getLong();
            long person2Id = queryParameters.getLong();

            if (printHeapUsage)
                heapUsage.print(System.out);

            List<LdbcQuery14Result> results = query(db, person1Id, person2Id);

            if (beVerbose)
                print(person1Id, person2Id, results);
       }
    }

    /**
     * Explain the query with the first set of query parameters.
     * @param db               A database handle
     * @param queryParameters  Stream of query input parameters
     * @throws SQLException if a database access error occurs
     */
    public void explainQuery(HikariDataSource db, QueryParameterFile queryParameters) throws SQLException {
        System.out.println("Explain is not supported for this query at this time.");
    }

    /**
     * Pretty print the query 14 results.
     * @param person1Id  Query 14 parameter 1
     * @param person2Id  Query 14 parameter 2
     * @param results    Query 14 results
     */
    private static void print(long person1Id, long person2Id, List<LdbcQuery14Result> results) {
        System.out.println(person1Id + " " + person2Id);
        if (results.size() == 0) {
            System.out.println("  no matches");
            System.out.println("");
            return;
        }

        Collections.sort(
            results,
            new Comparator<Object>() {
                @Override
                public int compare(Object o1, Object o2) {
                    LdbcQuery14Result r1 = (LdbcQuery14Result)o1;
                    LdbcQuery14Result r2 = (LdbcQuery14Result)o2;
                    double w1 = r1.pathWeight();
                    double w2 = r2.pathWeight();
                    if (w1 == w2) {
                        Iterator i1 = r1.personsIdsInPath().iterator();
                        Iterator i2 = r2.personsIdsInPath().iterator();
                        long id1 = -1;
                        long id2 = -1;
                        while (i1.hasNext()) {
                            id1 = (long)i1.next();
                            id2 = (long)i2.next();
                            if (id1 != id2)
                                break;
                        }
                        return Long.compare(id1, id2);
                    }
                    else
                        return Double.compare(w2, w1); // Descending
                }
            });

        for (LdbcQuery14Result result : results) {
            System.out.print("  " + result.pathWeight());
            for (Object o : result.personsIdsInPath())
                System.out.print(", " + o);
            System.out.println();
        }
        System.out.println("");
    }

}
