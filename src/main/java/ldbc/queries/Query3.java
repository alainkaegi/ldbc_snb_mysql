/*
 * Copyright © 2018 Alain Kägi
 */

package ldbc.queries;

import com.ldbc.driver.workloads.ldbc.snb.interactive.LdbcQuery3Result;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.TimeZone;

import java.text.SimpleDateFormat;

import ldbc.helpers.Query3Counts;
import ldbc.helpers.Query3SortResult;

import ldbc.utils.Explanation;
import ldbc.utils.LdbcUtils;

/**
 * The Query3 class implements an application that runs complex read
 * query 3 from the LDBC Social Network Benchmark (SNB) as a
 * microbenchmark.  As input, it expects a parameter substitution
 * parameter file as generated by the LDBC SNB data generator.
 */
public class Query3 implements ExecutableQuery {

    /* Static query parameters. */
    private static final String queryName = "Query3";
    private static final String queryParameterFilename = "query_3_param.txt";
    private static final String queryParameterFileLinePattern = "(\\d+)\\|(\\d+)\\|(\\d+)\\|(.+)\\|(.+)";
    private static final int queryLimit = 20;
    // Friends that have been in both the given countries in the given
    // time line.
    // Parameter 1: country X identifier
    // Parameter 2: country Y identifier
    // Parameter 3: start date (milliseconds since the start of the epoch)
    // Parameter 4: end date (milliseconds since the start of the epoch)
    // Parameter 5: country X identifier (same as parameter 1)
    // Parameter 6: country Y identifier (same as parameter 2)
    // Parameter 7: start date (same as parameter 3)
    // Parameter 8: end date (same as parameter 4)
    // Parameter 9: person identifier
    // Parameter 10: person identifier (same as parameter 9)
    // Parameter 11: person identifier (same as parameter 9)
    // Parameter 12: country X identifier (same as parameter 1)
    // Parameter 13: country Y identifier (same as parameter 2)
    private static final String queryString =
        "   SELECT Person.Id, " +
        "          U1.placeId " +
        "     FROM (SELECT PostIsLocatedInPlace.postId AS messageId, " +
        "                  PostIsLocatedInPlace.placeId " +
        "             FROM PostIsLocatedInPlace, Message " +
        "            WHERE (PostIsLocatedInPlace.placeId = ? " +
        "                   OR PostIsLocatedInPlace.placeId = ?) " +
        "              AND Message.id = PostIsLocatedInPlace.postId " +
        "              AND Message.creationDate >= ? " +
        "              AND Message.creationDate < ? " +
        "            UNION " +
        "           SELECT CommentIsLocatedInPlace.commentId AS messageId, " +
        "                  CommentIsLocatedInPlace.placeId " +
        "             FROM CommentIsLocatedInPlace, Message " +
        "            WHERE (CommentIsLocatedInPlace.placeId = ? " +
        "                   OR CommentIsLocatedInPlace.placeId = ?) " +
        "              AND Message.id = CommentIsLocatedInPlace.commentId " +
        "              AND Message.creationDate >= ? " +
        "              AND Message.creationDate < ? " +
        "          ) AS U1, " +
        "          (SELECT PersonKnowsPerson.person2Id AS friendId " +
        "             FROM PersonKnowsPerson " +
        "            WHERE PersonKnowsPerson.person1Id = ? " +
        "            UNION " +
        "           SELECT K2.person2Id AS friendId " +
        "             FROM PersonKnowsPerson AS K1, " +
        "                  PersonKnowsPerson AS K2 " +
        "            WHERE K1.person1Id = ? " +
        "              AND K2.person1Id = K1.person2Id " +
        "              AND K2.person2Id <> ? " +
        "          ) AS U2, " +
        "          Person, " +
        "          MessageHasCreatorPerson, " +
        "          PersonIsLocatedInPlace, " +
        "          PlaceIsPartOfPlace " +
        "    WHERE Person.id = U2.friendId " +
        "      AND MessageHasCreatorPerson.personId = Person.id " +
        "      AND MessageHasCreatorPerson.messageId = U1.messageId " +
        "      AND PersonIsLocatedInPlace.personId = Person.id " +
        "      AND PlaceIsPartOfPlace.place1Id = PersonIsLocatedInPlace.placeId " +
        "      AND PlaceIsPartOfPlace.place2Id <> ? " +
        "      AND PlaceIsPartOfPlace.place2Id <> ?";

    /** A minimal constructor. */
    private Query3() {}

    /**
     * Run LDBC SNB complex read query 3 as a microbenchmark.
     *
     * <p>A configuration file called <tt>params.ini</tt> specifies
     * the running parameters.
     *
     * @param args  Unused
     */
    public static void main(String[] args) {
        Microbenchmark.executeQueryWithParametersFromFile(new Query3(), queryName, queryParameterFilename, queryParameterFileLinePattern);
    }

    /**
     * Friends that have been to countries X and Y (third complex read query).
     * @param db         A database handle
     * @param personId   The person's unique identifier
     * @param countryX   Country X's name
     * @param countryY   Country Y's name
     * @param startDate  A start date (milliseconds since the start of the epoch)
     * @param duration   Duration in days
     * @param limit      An upper bound on the number of results returned
     * @return the top 'limit' friends of the given person that have visited countries X and Y
     * @throws SQLException if a database access error occurs
     */
    public static List<LdbcQuery3Result> query(Connection db, long personId, String countryX, String countryY, long startDate, int duration, int limit) throws SQLException {

        // Create a priority queue to keep the results sorted and
        // limited to at most the requested 'limit' entries.  To make
        // this work, we inverse the sort order so we know it is safe
        // to remove the entry with the "highest" priority when the
        // queue reaches 'limit + 1' elements.
        Queue<Query3SortResult> queue = new PriorityQueue<>(limit + 1);

        try {
            db.setAutoCommit(false);

            long endDate = startDate + (long)duration * 24 * 60 * 60 * 1000;

            long countryXId = LdbcUtils.getCountryId(db, countryX);
            long countryYId = LdbcUtils.getCountryId(db, countryY);

            // Accumulate counts per country.
            Map<Long, Query3Counts> counts = new HashMap<>();

            PreparedStatement s = db.prepareStatement(queryString);
            s.setLong(1, countryXId);
            s.setLong(2, countryYId);
            s.setLong(3, startDate);
            s.setLong(4, endDate);
            s.setLong(5, countryXId);
            s.setLong(6, countryYId);
            s.setLong(7, startDate);
            s.setLong(8, endDate);
            s.setLong(9, personId);
            s.setLong(10, personId);
            s.setLong(11, personId);
            s.setLong(12, countryXId);
            s.setLong(13, countryYId);
            ResultSet r = s.executeQuery();
            while (r.next()) {
                long friendId = r.getLong("Person.id");
                long countryId = r.getLong("U1.placeId");

                Query3Counts c = counts.get(friendId);
                if (c == null)
                    counts.put(friendId,
                               new Query3Counts(countryId == countryXId ? 1 : 0,
                                                countryId == countryYId ? 1 : 0));
                else if (countryId == countryXId)
                    c.incXCount();
                else
                    c.incYCount();
            }
            r.close();
            s.close();

            for (Map.Entry<Long, Query3Counts> entry : counts.entrySet()) {
                long friendId = entry.getKey();
                Query3Counts c = entry.getValue();
                int countx = c.getXCount();
                int county = c.getYCount();

                // Only include friends who have been to both
                // countries.
                if (countx != 0 && county != 0) {
                    Query3SortResult e = new Query3SortResult(
                        friendId,
                        LdbcUtils.getFirstName(db, friendId),
                        LdbcUtils.getLastName(db, friendId),
                        countx,
                        county);

                    queue.add(e);

                    // Eliminate the 'highest' priority entry if we
                    // have reached the target number of results.
                    Query3SortResult ignore;
                    if (queue.size() > limit)
                        ignore = queue.poll();
                }
            }

            db.commit();
        } finally {
            db.setAutoCommit(true);
        }

        List<LdbcQuery3Result> results = new ArrayList<>();

        // Add elements to the final result array in reverse order.
        while (queue.size() != 0) {
            Query3SortResult e = queue.poll(); // Dequeue.
            LdbcQuery3Result result = new LdbcQuery3Result(
                e.friendId(),
                e.friendFirstName(),
                e.friendLastName(),
                e.xCount(),
                e.yCount(),
                e.xCount() + e.yCount());
            results.add(0, result); // Add at the front.
        }

        return results;
    }

    /**
     * Explain the main query for the given inputs.
     * @param db         A database handle
     * @param personId   The person's unique identifier
     * @param firstName  A first name
     * @param limit      An upper bound on the number of results returned
     * @return the top 'limit' friends of the given person with the given first name
     * @throws SQLException if a database access error occurs
     */
    private static ResultSet explain(Connection db, long personId, String countryX, String countryY, long startDate, int duration, int limit) throws SQLException {
        long endDate = startDate + (long)duration * 24 * 60 * 60 * 1000;
        long countryXId = LdbcUtils.getCountryId(db, countryX);
        long countryYId = LdbcUtils.getCountryId(db, countryY);
        PreparedStatement s = db.prepareStatement(Explanation.query + queryString);
        s.setLong(1, countryXId);
        s.setLong(2, countryYId);
        s.setLong(3, startDate);
        s.setLong(4, endDate);
        s.setLong(5, countryXId);
        s.setLong(6, countryYId);
        s.setLong(7, startDate);
        s.setLong(8, endDate);
        s.setLong(9, personId);
        s.setLong(10, personId);
        s.setLong(11, personId);
        s.setLong(12, countryXId);
        s.setLong(13, countryYId);
        return s.executeQuery();
    }

    /**
     * Execute the query once for every query parameters.
     * @param db               A database handle
     * @param queryParameters  Stream of query input parameters
     * @param beVerbose        Print query outputs if true
     * @param printHeapUsage   Print heap usage if true
     * @throws SQLException if a database access error occurs
     */
    public void executeQuery(Connection db, QueryParameterFile queryParameters, boolean beVerbose, boolean printHeapUsage) throws SQLException {
        HeapUsage heapUsage = new HeapUsage();

        while (queryParameters.nextLine()) {
            long personId = queryParameters.getLong();
            long startDate = queryParameters.getLong();
            int duration = queryParameters.getInt();
            String countryX = queryParameters.getString();
            String countryY = queryParameters.getString();

            if (printHeapUsage)
                heapUsage.print(System.out);

            List<LdbcQuery3Result> results = query(db, personId, countryX, countryY, startDate, duration, queryLimit);

            if (beVerbose)
                print(personId, countryX, countryY, startDate, duration, results);
       }
    }

    /**
     * Explain the query with the first set of query parameters.
     * @param db               A database handle
     * @param queryParameters  Stream of query input parameters
     * @throws SQLException if a database access error occurs
     */
    public void explainQuery(Connection db, QueryParameterFile queryParameters) throws SQLException {
        if (queryParameters.nextLine()) {
            long personId = queryParameters.getLong();
            long startDate = queryParameters.getLong();
            int duration = queryParameters.getInt();
            String countryX = queryParameters.getString();
            String countryY = queryParameters.getString();

            ResultSet r = explain(db, personId, countryX, countryY, startDate, duration, queryLimit);

            ldbc.utils.Explanation.print(System.out, r);
        }
    }

    /**
     * Pretty print the query 3 results.
     * @param personId   Query 3 parameter 1
     * @param countryX   Query 3 parameter 2
     * @param countryY   Query 3 parameter 3
     * @param startDate  Query 3 parameter 4
     * @param duration   Query 3 parameter 5
     * @param results    Query 3 results
     */
    private static void print(long personId, String countryX, String countryY, long startDate, int duration, List<LdbcQuery3Result> results) {
        SimpleDateFormat dateTimeFmt = new SimpleDateFormat("EEE MMM dd HH:mm:ss yyyy");
        dateTimeFmt.setTimeZone(TimeZone.getTimeZone("UTC"));
        System.out.println(personId
                           + " " + dateTimeFmt.format(startDate)
                           + " " + dateTimeFmt.format(startDate + (long)duration * 24 * 60 * 60 * 1000)
                           + " " + countryX
                           + " " + countryY);

        if (results.size() == 0) {
            System.out.println("  no matches");
            System.out.println("");
            return;
        }

        for (LdbcQuery3Result result : results) {
            System.out.println("  " + result.personId()
                               + ", " + result.personFirstName()
                               + " " + result.personLastName()
                               + ", " + result.xCount()
                               + ", " + result.yCount()
                               + ", " + result.count());
        }
        System.out.println("");
    }

}
