/*
 * Copyright © 2018 Alain Kägi
 */

package ldbc.queries;

import com.ldbc.driver.workloads.ldbc.snb.interactive.LdbcQuery1Result;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Set;
import java.util.TimeZone;

import java.text.SimpleDateFormat;

import ldbc.helpers.Query1SortResult;

import ldbc.utils.Explanation;
import ldbc.utils.LdbcUtils;

/**
 * The Query1 class implements an application that runs complex read
 * query 1 from the LDBC Social Network Benchmark (SNB) as a
 * microbenchmark.  As input, it expects a parameter substitution
 * parameter file as generated by the LDBC SNB data generator.
 */
public class Query1 implements ExecutableQuery {

    /* Static query parameters. */
    private static final String queryName = "Query1";
    private static final String queryParameterFilename = "query_1_param.txt";
    private static final String queryParameterFileLinePattern = "(\\d+)\\|(.+)";
    private static final int queryLimit = 20;
    // Friend of a person (and details about that friend).
    private static final String queryString =
        "   SELECT Person.id, Person.firstName, Person.lastName, " +
        "          Person.birthday, Person.creationDate, Person.gender, " +
        "          Person.browserUsed, Person.locationIP " +
        "     FROM Person, PersonKnowsPerson " +
        "    WHERE PersonKnowsPerson.person1Id = ? " +
        "      AND Person.id = PersonKnowsPerson.person2Id";

    /** A minimal constructor. */
    private Query1() {}

    /**
     * Run LDBC SNB complex read query 1 as a microbenchmark.
     *
     * <p>A configuration file called <tt>params.ini</tt> specifies
     * the running parameters.
     *
     * @param args  Unused
     */
    public static void main(String[] args) {
        Microbenchmark.executeQueryWithParametersFromFile(new Query1(), queryName, queryParameterFilename, queryParameterFileLinePattern);
    }

    /**
     * Friends with a certain name (first complex read query).
     * @param db         A database handle
     * @param personId   The person's unique identifier
     * @param firstName  A first name
     * @param limit      An upper bound on the number of results returned
     * @return the top 'limit' friends of the given person with the given first name
     * @throws SQLException if a database access error occurs
     */
    public static List<LdbcQuery1Result> query(Connection db, long personId, String firstName, int limit) throws SQLException {

        // Create a priority queue to keep the results sorted and
        // limited to at most the requested 'limit' entries.  To make
        // this work, we inverse the sort order so we know it is safe
        // to remove the entry with the "highest" priority when the
        // queue reaches 'limit + 1' elements.
        Queue<Query1SortResult> queue = new PriorityQueue<>(limit + 1);

        // Breadth-first search:
        // open: the nodes at the current distance
        // nextOpen: the nodes at the current distance + 1
        // close: the nodes we have already seen
        Queue<Long> open = new LinkedList<>();
        Queue<Long> nextOpen = new LinkedList<>();
        Set<Long> close = new HashSet<>();

        int distance = 1;
        open.add(personId);
        close.add(personId);

        // First, using a breadth first search, find the friends
        // within the appropriate distance who are matching the search
        // criteria.
        try {
            db.setAutoCommit(false);

            bfs:
            while (distance < 4) {

                for (Long person : open) {

                    // Look for the friends of person.
                    PreparedStatement s = db.prepareStatement(queryString);
                    s.setLong(1, person);
                    ResultSet r = s.executeQuery();
                    while (r.next()) {

                        long friendId = r.getLong("Person.id");

                        // We've already seen this friend.
                        if (close.contains(friendId))
                            continue;

                        nextOpen.add(friendId);
                        close.add(friendId);

                        String friendFirstName = r.getString("Person.firstName");
                        // Add this friend if we have a match.
                        if (friendFirstName.equals(firstName)) {
                            Query1SortResult e = new Query1SortResult(
                                friendId,
                                r.getString("Person.lastName"),
                                distance,
                                r.getLong("Person.birthday"),
                                r.getLong("Person.creationDate"),
                                r.getString("Person.gender"),
                                r.getString("Person.browserUsed"),
                                r.getString("locationIP"),
                                LdbcUtils.getEmails(db, friendId),
                                LdbcUtils.getLanguages(db, friendId),
                                LdbcUtils.findPlace(db, friendId),
                                LdbcUtils.findSchools(db, friendId),
                                LdbcUtils.findOrganizations(db, friendId));

                            queue.add(e);

                            // Eliminate the 'highest' priority entry
                            // if we have reached the target number of
                            // results.
                            Query1SortResult ignore;
                            if (queue.size() > limit)
                                ignore = queue.poll();
                        }
                    }

                    r.close();
                    s.close();
                }

                ++distance;
                open = nextOpen;
                nextOpen = new LinkedList<>();
            }
            db.commit();
        } finally {
            db.setAutoCommit(true);
        }

        List<LdbcQuery1Result> results = new ArrayList<>();

        // Add elements to the final result array in reverse order.
        while (queue.size() != 0) {
            Query1SortResult e = queue.poll(); // Dequeue.
            LdbcQuery1Result result = new LdbcQuery1Result(
                e.friendId(),
                e.friendLastName(),
                e.friendDistanceFromPerson(),
                e.friendBirthday(),
                e.friendCreationDate(),
                e.friendGender(),
                e.friendBrowserUsed(),
                e.friendLocationIP(),
                e.friendEmails(),
                e.friendLanguages(),
                e.friendPlace(),
                e.friendSchools(),
                e.friendOrganizations());
            results.add(0, result); // Add at the front.
        }

        return results;
    }

    /**
     * Explain the main query for the given inputs.
     * @param db         A database handle
     * @param personId   The person's unique identifier
     * @param firstName  A first name
     * @param limit      An upper bound on the number of results returned
     * @return the top 'limit' friends of the given person with the given first name
     * @throws SQLException if a database access error occurs
     */
    private static ResultSet explain(Connection db, long personId, String firstName, int limit) throws SQLException {
        PreparedStatement s = db.prepareStatement(Explanation.query + queryString);
        s.setLong(1, personId);
        return s.executeQuery();
    }

    /**
     * Execute the query once for every query parameters.
     * @param db               A database handle
     * @param queryParameters  Stream of query input parameters
     * @param beVerbose        Print query outputs if true
     * @param printHeapUsage   Print heap usage if true
     * @throws SQLException if a database access error occurs
     */
    public void executeQuery(Connection db, QueryParameterFile queryParameters, boolean beVerbose, boolean printHeapUsage) throws SQLException {
        HeapUsage heapUsage = new HeapUsage();

        while (queryParameters.nextLine()) {
            long personId = queryParameters.getLong();
            String firstName = queryParameters.getString();

            if (printHeapUsage)
                heapUsage.print(System.out);

            List<LdbcQuery1Result> results = query(db, personId, firstName, queryLimit);

            if (beVerbose)
                print(personId, firstName, results);
       }
    }

    /**
     * Explain the query with the first set of query parameters.
     * @param db               A database handle
     * @param queryParameters  Stream of query input parameters
     * @throws SQLException if a database access error occurs
     */
    public void explainQuery(Connection db, QueryParameterFile queryParameters) throws SQLException {
        if (queryParameters.nextLine()) {
            long personId = queryParameters.getLong();
            String firstName = queryParameters.getString();

            ResultSet r = explain(db, personId, firstName, queryLimit);

            ldbc.utils.Explanation.print(System.out, r);
        }
    }

    /**
     * Pretty print the query 1 results.
     * @param personId   Query 1 parameter 1
     * @param firstName  Query 1 parameter 2
     * @param results    Query 1 results
     * The function sorts languages, schools, and organizations before
     * printing them so we can more easily compare output with other
     * implementations.
     */
    private static void print(long personId, String firstName, List<LdbcQuery1Result> results) {
        System.out.println(personId + " " + firstName);

        if (results.size() == 0) {
            System.out.println("  no matches");
            System.out.println("");
            return;
        }

        SimpleDateFormat dateFmt = new SimpleDateFormat("yyyy-MM-dd");
        dateFmt.setTimeZone(TimeZone.getTimeZone("UTC"));
        SimpleDateFormat dateTimeFmt = new SimpleDateFormat("EEE MMM dd HH:mm:ss yyyy");
        dateTimeFmt.setTimeZone(TimeZone.getTimeZone("UTC"));

        for (LdbcQuery1Result result : results) {
            System.out.println("  " + result.distanceFromPerson()
                               + ", " + result.friendId()
                               + ", " + result.friendLastName()
                               + ", " + dateFmt.format(new Date(result.friendBirthday()))
                               + ", " + dateTimeFmt.format(new Date(result.friendCreationDate()))
                               + ", " + result.friendGender()
                               + ", " + result.friendBrowserUsed()
                               + ", " + result.friendLocationIp());
            for (String email : result.friendEmails())
                System.out.println("    " + email);
            int size = 0;
            List<String> languages = new ArrayList<>();
            for (String language : result.friendLanguages()) {
                languages.add(language);
                size++;
            }
            Collections.sort(languages);
            int count = 0;
            System.out.print("    ");
            for (String language : languages) {
                count++;
                if (count != size)
                    System.out.print(language + ", ");
                else
                    System.out.println(language);
            }
            System.out.println("    " + result.friendCityName());
            List<List<Object>> schools = new ArrayList<>();
            for (List<Object> school : result.friendUniversities())
                schools.add(school);
            Collections.sort(
                schools,
                new Comparator<Object>() {
                    @Override
                    public int compare(Object o1, Object o2) {
                        String name1 = o1.toString();
                        String name2 = o2.toString();
                        return name1.compareTo(name2);
                    }
                });
            for (List<Object> school : schools)
                System.out.println("    " + school.get(0)
                                   + ", " + school.get(1)
                                   + ", " + school.get(2));
            List<List<Object>> organizations = new ArrayList<>();
            for (List<Object> organization : result.friendCompanies())
                organizations.add(organization);
            Collections.sort(
                organizations,
                new Comparator<Object>() {
                    @Override
                    public int compare(Object o1, Object o2) {
                        String name1 = o1.toString();
                        String name2 = o2.toString();
                        return name1.compareTo(name2);
                    }
                });
            for (List<Object> organization : organizations)
                System.out.println("    " + organization.get(0)
                                   + ", " + organization.get(1)
                                   + ", " + organization.get(2));
        }
        System.out.println("");
    }

}
